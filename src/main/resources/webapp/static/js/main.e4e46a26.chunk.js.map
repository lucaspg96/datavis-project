{"version":3,"sources":["websocket.js","components/MapContainer/MapContainer.jsx","components/CountContainer/CountContainer.jsx","components/MainContainer.jsx","App.js","serviceWorker.js","index.js"],"names":["websocketURL","window","location","host","markerIcon","L","divIcon","className","html","MapContainer","useState","map","setMap","useEffect","center","zoom","layers","tileLayer","attribution","WebSocket","onmessage","message","tweet","position","marker","icon","addTo","bindPopup","ReactDOMServer","renderToString","author","userName","content","text","datetime","date","createPopup","setTimeout","remove","createMarker","JSON","parse","data","id","Search","Input","options","colors","enableTooltip","deterministic","fontFamily","fontSizes","fontStyle","fontWeight","padding","rotations","rotationAngles","scale","spiral","transitionDuration","CountContainer","wordsFrequencies","useRef","wordCloud","setWordCloud","ws","setWs","search","setSearch","drop","setDrop","size","setSize","normalizeCount","setNormalizeCount","spin","setSpin","Date","getTime","targetTime","setTargetTime","updateWordCloud","current","length","newWordCloud","Object","entries","value","sort","a","b","splice","i","shift","normalizedCloud","values","m","mean","s","std","word","normalize","close","newWs","encodeURIComponent","wordCount","forEach","frequency","onclose","console","log","keys","warning","startWebsocket","spinning","placeholder","enterButton","onSearch","defaultValue","onChange","target","onEnd","words","TabPane","Tabs","MainContainer","defaultActiveKey","type","tab","key","App","Boolean","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e4e46a26.chunk.js","sourcesContent":["const host = window.location.host\n\nconst websocketURL = \"ws://\" + host;\n// const websocketURL = \"ws://localhost:9000\";\nexport default websocketURL;","import React, { useState, useEffect } from 'react';\nimport ReactDOMServer from 'react-dom/server'\nimport { Comment } from 'antd';\nimport L from 'leaflet'\nimport websocketURL from '../../websocket'\nimport './MapContainer.scss';\n\nconst markerIcon = L.divIcon({\n    className: 'css-icon',\n    html: '<div class=\"tweet-map-marker\"></div>'\n});\n\nexport function MapContainer() {\n\n    const [map, setMap] = useState(null);\n\n    useEffect(() => {\n        if (map == null) {\n            setMap(L.map('map', {\n                center: [0, 0],\n                zoom: 2,\n                layers: [\n                    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {\n                        attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n                    }),\n                ]\n            }));\n        }\n    })\n\n    useEffect(() => {\n        if (map != null) {\n            const ws = new WebSocket(websocketURL + '/tweets?geolocated=true');\n            ws.onmessage = (message) => {\n                const tweet = JSON.parse(message.data);\n                createMarker(tweet);\n            }\n        }\n\n    }, [map])\n\n    function createMarker(tweet) {\n        if (tweet.position) {\n            const marker = L.marker(tweet.position, {\n                icon: markerIcon\n            })\n                .addTo(map)\n                .bindPopup(createPopup(tweet))\n\n            setTimeout(() => {\n                marker.remove()\n            }, 5000)\n        }\n\n    }\n\n    function createPopup(tweet) {\n        return ReactDOMServer.renderToString(\n            <Comment\n                author={tweet.userName}\n                content={\n                    <p>\n                        {tweet.text}\n                    </p>\n                }\n                datetime={tweet.date}\n            />\n        );\n    }\n\n    return <div id=\"map\"></div>\n}","import React, { useRef, useState, useEffect } from 'react';\nimport { mean, std } from \"mathjs\";\nimport ReactWordcloud from 'react-wordcloud';\nimport './CountContainer.scss';\nimport CountDown from 'ant-design-pro/lib/CountDown';\nimport websocketURL from '../../websocket'\nimport { Input, InputNumber, Spin, Checkbox, message } from 'antd';\n\nconst { Search } = Input;\n\nconst options = {\n    colors: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'],\n    enableTooltip: true,\n    deterministic: true,\n    fontFamily: 'impact',\n    fontSizes: [5, 60],\n    fontStyle: 'normal',\n    fontWeight: 'normal',\n    padding: 1,\n    rotations: 3,\n    rotationAngles: [0, 90],\n    scale: 'sqrt',\n    spiral: 'archimedean',\n    transitionDuration: 1000,\n};\n\nexport default function CountContainer() {\n    const wordsFrequencies = useRef({});\n    const [wordCloud, setWordCloud] = useState([])\n    const [ws, setWs] = useState();\n    const [search, setSearch] = useState();\n    const [drop, setDrop] = useState(0);\n    const [size, setSize] = useState(50);\n    const [normalizeCount, setNormalizeCount] = useState(false);\n    const [spin, setSpin] = useState(false);\n    const [targetTime, setTargetTime] = useState(new Date().getTime() + 5000);\n\n    useEffect(() => {\n        startWebsocket();\n    }, [search])\n\n    useEffect(() => {\n        updateWordCloud();\n    }, [drop, size, normalizeCount])\n\n    function startWebsocket() {\n        if (ws) ws.close(3000);\n        setWordCloud([]);\n        setSpin(true);\n        wordsFrequencies.current = {};\n\n        const newWs = search ?\n            new WebSocket(websocketURL + '/tweets?keywords=' + encodeURIComponent(search)) :\n            new WebSocket(websocketURL + '/tweets')\n        newWs.onmessage = (message) => {\n            const tweet = JSON.parse(message.data);\n            Object.entries(tweet.wordCount).forEach(([word, frequency]) => {\n                wordsFrequencies.current[word] = (wordsFrequencies.current[word] || 0) + frequency;\n            });\n        };\n\n        newWs.onclose = () => {\n            console.log(\"closing websocket\")\n        }\n\n        setWs(newWs);\n        setTargetTime(new Date().getTime() + 5000);\n\n        setTimeout(() => {\n            if (Object.keys(wordsFrequencies.current).length === 0) {\n                message.warning(\"Nenhum twitter encontrado até o momento\")\n            }\n            setSpin(false);\n        }, 5000)\n    }\n\n    function normalize(wordCloud) {\n        if (wordCloud.length === 0 || !normalizeCount)\n            return wordCloud;\n\n        const values = wordCloud.map(({ value }) => value)\n        const m = mean(values)\n        const s = std(values)\n\n        return wordCloud.map(word => {\n            return {\n                ...word,\n                value: (word.value + m) / s\n            };\n        });\n    }\n\n    function updateWordCloud() {\n        if (wordsFrequencies.current.length === 0) return;\n        const newWordCloud = Object\n            .entries(wordsFrequencies.current)\n            .map(([word, frequency]) => {\n                return {\n                    text: word,\n                    value: frequency\n                };\n            })\n            .sort((a, b) => b.value - a.value)\n            // .filter(({ value }) => value > 1)\n            .splice(0, size);\n\n        for (let i = 0; i < drop; i++) newWordCloud.shift();\n\n        const normalizedCloud = normalize(newWordCloud);\n        setWordCloud(normalizedCloud);\n        setTargetTime(new Date().getTime() + 5000)\n    }\n\n    return <div className=\"word-cloud-container\">\n        <Spin spinning={spin}>\n            <div className=\"word-cloud-fields\">\n                <div className=\"word-cloud-field\">\n                    <Search\n                        placeholder=\"Filtrar tweets\"\n                        enterButton=\"Filtrar!\"\n                        size=\"small\"\n                        onSearch={setSearch}\n                    />\n                </div>\n                <div className=\"word-cloud-field\">\n                    <span>Número de palavras: </span><InputNumber defaultValue={size} onChange={setSize} />\n                </div>\n                <div className=\"word-cloud-field\">\n                    <span>Pular palavras: </span><InputNumber defaultValue={drop} onChange={setDrop} />\n                </div>\n                <div className=\"word-cloud-field\">\n                    <Checkbox onChange={setNormalizeCount}> Normalizar Frequências </Checkbox>\n                </div>\n            </div>\n        </Spin>\n        <CountDown\n            className=\"count-down-refresh\"\n            target={targetTime}\n            onEnd={updateWordCloud}\n        />\n        {wordCloud.length !== 0 && <ReactWordcloud words={wordCloud} options={options} />}\n    </div>;\n}","import React from 'react'\nimport { MapContainer } from './MapContainer/MapContainer';\nimport { Tabs } from 'antd';\nimport 'antd/dist/antd.css';\nimport \"./MapContainer.scss\";\nimport CountContainer from './CountContainer/CountContainer';\n\nconst { TabPane } = Tabs;\n\nexport default function MainContainer() {\n    return <Tabs defaultActiveKey=\"1\"\n        type=\"card\"\n    >\n        <TabPane tab=\"Mapa\" key=\"1\">\n            <MapContainer />\n        </TabPane>\n        <TabPane tab=\"Contagem\" key=\"2\">\n            <CountContainer />\n        </TabPane>\n    </Tabs>;\n}","import React from 'react';\nimport './App.css';\nimport MainContainer from './components/MainContainer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <MainContainer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}