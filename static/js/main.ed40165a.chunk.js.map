{"version":3,"sources":["services/index.js","map/MapController.jsx","components/RealTimeContainer/TweetsStatistics.jsx","components/RealTimeContainer/RealTimeContainer.jsx","components/MainContainer.jsx","services/TwitterService.js","components/Statics/StaticMainContainer.jsx","App.js","serviceWorker.js","index.js"],"names":["window","location","host","map","dataWithoutPosition","legend","undefined","markersLayer","createMap","containerId","L","center","zoom","layers","tileLayer","attribution","clearMarkers","clearLayers","createMarker","tweet","layerGroup","addTo","marker","position","icon","divIcon","className","html","color","bindPopup","content","author","userName","text","datetime","date","toLocaleTimeString","ReactDOMServer","renderToString","createPopup","id","addMarker","duration","staticMap","setTimeout","remove","updateLegend","d3","control","onAdd","div","DomUtil","create","innerHTML","TweetsStatistics","statistics","selectable","onClick","selected","users","retweets","mediaAndLinks","total","mentions","replies","geolocated","originals","gutter","title","trigger","onVisibleChange","console","log","span","value","_","includes","Input","Search","Tabs","TabPane","service","axios","baseURL","apiURL","get","then","res","data","Option","Select","wordsColors","formatFunctions","minutes","seconds","hour","day","StaticMainContainer","useState","setData","selectedKeys","setSelectedKeys","selectedTypes","setSelectedTypes","wordChart","useRef","barChart","setBarChart","pieChart","setPieChart","filteredData","filter","t","length","key","type","colors","setStatistics","metrics","Set","coloredKeys","setColors","dateFormater","setDateFormater","dateFormatSelect","defaultValue","onChange","f","facts","setFacts","processData","forEach","d","Date","parseInt","$numberLong","retweet","reply","keyColor","i","newData","addColorToData","drawWordChart","dv","wc","wordCount","Object","entries","word","count","sort","a","b","slice","getWordCount","isEmpty","DataSet","View","source","range","min","max","transform","spiral","fields","font","size","padding","timeInterval","Infinity","rotate","random","Math","fontSize","configWorldCloud","colorRange","domain","quantileSeq","rows","current","destroy","chart","Chart","container","autoFit","height","scale","x","nice","y","axis","tooltip","showTitle","showMarkers","coordinate","reflect","point","v","shape","render","drawSeriesChart","timeDimension","dimension","timeCountGroup","group","timeScale","dateSeriesChart","dc","width","c","curve","renderDataPoints","margins","top","right","bottom","left","brushOn","yAxisLabel","xAxisLabel","clipPadding","elasticY","seriesAccessor","keyAccessor","valueAccessor","itemHeight","autoItemWidth","horizontal","k","colorAccessor","addMarkers","MapController","useEffect","TwitterService","catch","factsData","crossfilter","keyDimension","keyCountGroup","keyScale","keys","xUnits","ordinal","gap","renderHorizontalGridLines","on","drawBarChart","original","add","mediasAndLink","typesDimension","typesCountGroup","colorScale","innerRadius","drawSunburst","draw","registerShape","cfg","attrs","defaultStyle","style","textAlign","fontFamily","fill","stroke","textBaseline","getTextAttrs","textShape","addShape","Util","PI","subTitle","bordered","extra","App","Boolean","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"mfAAaA,OAAOC,SAASC,K,wDCMzBC,EAAM,KACNC,EAAsB,EACtBC,OAASC,EACTC,OAAeD,EAEZ,SAASE,EAAUC,GACtBN,EAAMO,IAAEP,IAAIM,EAAa,CACrBE,OAAQ,CAAC,EAAG,GACZC,KAAM,EACNC,OAAQ,CACJH,IAAEI,UAAU,gEAAiE,CACzEC,YAAa,gFA+BtB,SAASC,IACRT,GAAcA,EAAaU,cAC/Bb,EAAsB,EAGnB,SAASc,EAAaC,GAEpBZ,IACDA,EAAeG,IAAEU,aAAaC,MAAMlB,IAGxC,IAAMmB,EAASZ,IAAEY,OAAOH,EAAMI,SAAU,CACpCC,KAAMd,IAAEe,QAAQ,CACZC,UAAW,WACXC,KAAK,sEAAD,OACsBR,EAAMS,MAD5B,gBAIPC,UAlCT,SAAqBV,GAEjB,IAAMW,EAAU,kBAAC,IAAD,CACZC,OAAQZ,EAAMa,SACdF,QACI,2BACKX,EAAMc,MAGfC,SAAUf,EAAMgB,KAAKC,uBAEzB,OAAOC,IAAeC,eAClBR,GAsBWS,CAAYpB,IAI3B,OAFAG,EAAOkB,GAAKrB,EAAMqB,GAEXlB,EAIJ,SAASmB,EAAUtB,GAA6C,IAAtCuB,EAAqC,uDAA1B,IAAOC,EAAmB,wDAMlE,GAJKpC,IACDA,EAAeG,IAAEU,aAAaC,MAAMlB,IAGpCgB,EAAMI,SAAU,CAChB,IAAMD,EAASJ,EAAaC,GACvBE,MAAMd,GAGNoC,GACDC,YAAW,WACPtB,EAAOuB,WACRH,QAIPtC,GAAuB,EACvB0C,IAIR,SAASA,IACL,IAAMb,EAAO,UAA+B7B,EAA9BA,EAAsB,EAAvB,gEACTC,EAC4B,IAAxBD,EAA2BC,EAAOwC,SACjCE,SAAU,eACVd,KAAKA,KAGV5B,EAASK,IAAEsC,QAAQ,CAAEzB,SAAU,iBACxB0B,MAAQ,SAAA9C,GACX,IAAM+C,EAAMxC,IAAEyC,QAAQC,OAAO,MAAO,cAGpC,OAFAF,EAAIG,WAAapB,EAEViB,GAGX7C,EAAOgB,MAAMlB,I,oCC3GN,SAASmD,EAAT,GAIX,IAJuCC,EAIxC,EAJwCA,WAIxC,IAHDC,kBAGC,aAFDC,eAEC,MAFS,kBAAM,GAEf,MADDC,gBACC,MADU,GACV,IAUGH,EARII,aAFP,MAEe,EAFf,IAUGJ,EAPFK,gBAHD,MAGY,EAHZ,IAUGL,EANFM,qBAJD,MAIiB,EAJjB,IAUGN,EALFO,aALD,MAKS,EALT,IAUGP,EAJFQ,gBAND,MAMY,EANZ,IAUGR,EAHFS,eAPD,MAOW,EAPX,IAUGT,EAFFU,kBARD,MAQc,EARd,IAUGV,EADFW,iBATD,MASa,EATb,EAYD,OAAO,yBAAKxC,UAAU,+BACpB,kBAAC,IAAD,CAAKyC,OAAQ,CAAC,EAAG,KAEf,kBAAC,IAAD,CAASC,MAAM,kBAAkBC,QAAQ,QAAQC,gBAAiBC,QAAQC,KACxE,kBAAC,IAAD,CAAKC,KAtBM,GAuBT,kBAAC,IAAD,CAAWL,MAAM,QAAQM,MAAOZ,MAIpC,kBAAC,IAAD,CAASM,MAAM,yCACb,kBAAC,IAAD,CAAKK,KA5BM,GA6BT,kBAAC,IAAD,CAAWL,MAAM,iBAAiBM,MAAOT,MAI7C,kBAAC,IAAD,CAASG,MAAM,gDACb,kBAAC,IAAD,CAAKK,KAlCM,GAmCT,kBAAC,IAAD,CAAWL,MAAM,cAAWM,MAAOf,MAIvC,kBAAC,IAAD,CAASS,MAAM,iDACb,kBAAC,IAAD,CAAKK,KAxCM,GAyCT,kBAAC,IAAD,CAAWL,MAAM,mBAAgBM,MAAOb,MAI5C,kBAAC,IAAD,CAASO,MAAM,0CACb,kBAAC,IAAD,CAAKK,KA9CM,GA+CT,kBAAC,IAAD,CAAWL,MAAM,gBAAUM,MAAOX,MAItC,kBAAC,IAAD,CAASK,MAAM,qBACb,kBAAC,IAAD,CAAKK,KApDM,GAqDT,yBAAKhB,QAAS,SAAAkB,GAAC,OAAIlB,EAAQ,aACzB,kBAAC,IAAD,CAAW/B,UAAS,mBAAc8B,EAAa,aAAe,GAA1C,YAAgDE,EAASkB,SAAS,WAAa,WAAa,IAAMR,MAAM,WAAWM,MAAOd,OAKpJ,kBAAC,IAAD,CAASQ,MAAM,sBACb,kBAAC,IAAD,CAAKK,KA5DM,GA6DT,yBAAKhB,QAAS,SAAAkB,GAAC,OAAIlB,EAAQ,WACzB,kBAAC,IAAD,CAAW/B,UAAS,UAAK8B,EAAa,aAAe,GAAjC,YAAuCE,EAASkB,SAAS,SAAW,WAAa,IAAMR,MAAM,YAAYM,MAAOV,OAK1I,kBAAC,IAAD,CAASI,MAAM,2DACb,kBAAC,IAAD,CAAKK,KApEM,GAqET,yBAAKhB,QAAS,SAAAkB,GAAC,OAAIlB,EAAQ,cACzB,kBAAC,IAAD,CAAW/B,UAAS,UAAK8B,EAAa,aAAe,GAAjC,YAAuCE,EAASkB,SAAS,YAAc,WAAa,IAAMR,MAAM,YAAYM,MAAOR,S,6BC3DhIW,IAAXC,OCTYC,IAAZC,Q,kECDFC,G,OAAUC,IAAM9B,OAAO,CAAE+B,QAFjBC,2BAGC,aAGP,OAAOH,EAAQI,IAAI,sBAAsBC,MAAK,SAAAC,GAAG,OAAIA,EAAIC,SAHlD,aAOP,OAAON,IAAMG,IAAI,cAAcC,MAAK,SAAAC,GAAG,OAAIA,EAAIC,SCQ/CC,EAAWC,IAAXD,OAGFE,EAAc,CAAC,UAAW,UAAW,UAAW,WAEhDC,EAAkB,CACpBC,QAAS9C,aACT+C,QAAS/C,aACTgD,KAAMhD,WACNiD,IAAKjD,WAGF,SAASkD,IAAuB,IAAD,EAEVC,qBAFU,mBAE3BV,EAF2B,KAErBW,EAFqB,OAIMD,mBAAS,IAJf,mBAI3BE,EAJ2B,KAIbC,EAJa,OAOQH,mBAAS,IAPjB,mBAO3BI,EAP2B,KAOZC,EAPY,KAU5BC,EAAYC,mBAVgB,EAYFP,qBAZE,mBAY3BQ,EAZ2B,KAYjBC,EAZiB,OAaFT,qBAbE,mBAa3BU,EAb2B,KAajBC,EAbiB,KAe5BC,GAAgBtB,GAAQ,IACzBuB,QAXa,SAAAC,GAAC,OAA4B,IAAxBZ,EAAaa,QAAgBb,EAAaxB,SAASoC,EAAEE,QAYvEH,QATc,SAAAC,GAAC,OAA6B,IAAzBV,EAAcW,QAAgBX,EAAc1B,SAASoC,EAAEG,SAWzEC,EAAS,CAAC,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,WAnB/L,EAqBElB,mBAAS,IArBX,mBAqB3B3C,EArB2B,KAqBf8D,EArBe,KAsB5BC,GAAUb,iBAAO,CAAE9C,MAAO,IAAI4D,MAtBF,GAuBDrB,mBAAS,IAvBR,qBAuB3BsB,GAvB2B,MAuBdC,GAvBc,SAyBMvB,oBAAS,kBAAMN,EAAgBE,WAzBrC,qBAyB3B4B,GAzB2B,MAyBbC,GAzBa,MA0B5BC,GAAmB,kBAAC,IAAD,CAAQC,aAAc,UAAWC,SAAU,SAAAC,GAAC,OAAIJ,IAAgB,kBAAM/B,EAAgBmC,QAC3G,kBAACtC,EAAD,CAAQyB,IAAK,EAAGxC,MAAM,WAAtB,YACA,kBAACe,EAAD,CAAQyB,IAAK,EAAGxC,MAAM,WAAtB,WACA,kBAACe,EAAD,CAAQyB,IAAK,EAAGxC,MAAM,QAAtB,QACA,kBAACe,EAAD,CAAQyB,IAAK,EAAGxC,MAAM,OAAtB,QA9B8B,GAiCRwB,qBAjCQ,qBAiC3B8B,GAjC2B,MAiCpBC,GAjCoB,MAyClC,SAASC,GAAY1C,GACjBA,EAAK2C,SAAQ,SAAAC,GAPjB,IAAsBjH,EAQdiH,EAAEjG,KAAO,IAAIkG,KAAKC,SAASF,EAAEjG,KAAKoG,cAClCH,EAAEjB,MATYhG,EASQiH,GARhBI,QAAgB,UACjBrH,EAAMsH,MAAc,WACjB,cAQZtC,EA6WJ,SAAwBX,GACpB,IAAMkD,EAAW,GAKbC,EAAI,EAEFC,EAAUpD,EAAKrF,KAAI,SAAA6G,GACrB,OAAI0B,EAAS1B,EAAEE,KAAa,2BAAKF,GAAZ,IAAepF,MAAO8G,EAAS1B,EAAEE,OAE9CyB,EAAIvB,EAAOH,OAAS,EAAUD,GAClC0B,EAAS1B,EAAEE,KAAOE,EAAOuB,GACzBA,GAAK,EACE,2BAAK3B,GAAZ,IAAepF,MAAO8G,EAAS1B,EAAEE,WAEtCH,QAAO,SAAAC,GAAC,OAAIA,EAAEpF,SAGjB,OADA6F,GAAUiB,GACHE,EAhYCC,CAAerD,IAkG3B,SAASsD,KAEL,IAAMC,EA4CV,WACI,IAAMC,EA4PV,WACI,IAAMA,EAAK,GAEXlC,EAAaqB,SAAQ,YAAoB,IAAjBc,EAAgB,EAAhBA,UACpBC,OAAOC,QAAQF,GAAW9I,KAAI,mCAAEiJ,EAAF,KAAQC,EAAR,YAAmBL,EAAGI,GAAQC,GAASL,EAAGI,IAAS,SAGrF,IAAMH,EAAYC,OAAOC,QAAQH,GAC5B7I,KAAI,yCAAmB,CAAE+G,IAArB,KAA0BxC,MAA1B,SAIT,OAFAuE,EAAUK,MAAK,SAACC,EAAGC,GAAJ,OAAUA,EAAE9E,MAAQ6E,EAAE7E,SAEjCuE,EAAUhC,QAjdL,GAidgCgC,EAC7BA,EAAUQ,MAAM,EAldnB,IAyMEC,GACX,GAAIC,kBAAQX,GACR,OACJ,IAAMD,GAAK,IAAIa,IAAQC,MAAOC,OAAOd,GAJb,EAMLD,EAAGgB,MAAM,SANJ,mBAMjBC,EANiB,KAMZC,EANY,KA4BxB,OArBAlB,EAAGmB,UAAU,CACTC,OAAQ,cACRhD,KAAM,YACNiD,OAAQ,CAAC,MAAO,SAChBC,KAAM,QACNC,KAAM,CAAC,IAAK,KACZC,QAAS,EACTC,aAAcC,IACdC,OARS,WASL,IAAIC,KAA4B,EAAhBC,KAAKD,UAAgB,EAIrC,OAHe,IAAXA,IACAA,EAAS,GAEG,GAATA,GAEXE,SAfS,SAeAzC,GAGL,OADeA,EAAE1D,MAAQsF,IAAQC,EAAMD,GAA1B,GADe,MAK7BjB,EAxEI+B,GACX,GAAK/B,EAAL,CAHqB,MAIFA,EAAGgB,MAAM,SAJP,mBAMfgB,GANe,UAMFhI,kBAEdiI,OAAOC,YAAYlC,EAAGmC,KAAK/K,KAAI,SAAAiI,GAAC,OAAIA,EAAE1D,SAAQ,CAAC,EAAG,IAAM,IAAM,KAC9DqF,MAAMpE,IAEPa,EAAU2E,SACV3E,EAAU2E,QAAQC,UAGtB,IAAMC,EAAQ,IAAIC,IAAM,CACpBC,UAAW,aACXC,SAAS,EACTC,OAAQ,IACRlB,QAAS,IAGbc,EAAM7F,KAAKuD,EAAGmC,MACdG,EAAMK,MAAM,CACRC,EAAG,CAAEC,MAAM,GACXC,EAAG,CAAED,MAAM,KAEfP,EAAMhL,QAAO,GACbgL,EAAMS,MAAK,GACXT,EAAMU,QAAQ,CACVC,WAAW,EACXC,aAAa,IAEjBZ,EAAMa,aAAaC,UACnBd,EAAMe,QACD7K,SAAS,OACTK,MAAM,SAAS,SAAAyK,GAEZ,OAAOtB,EAAWsB,MAErBC,MAAM,SACXjB,EAAMkB,SAEN/F,EAAU2E,QAAUE,GAmExB,SAASmB,GAAgBxE,GACrB,IAAMyE,EAAgBzE,EAAM0E,WAAU,SAAAtE,GAAC,MAAI,CAACA,EAAElB,IAAKQ,GAAaU,EAAEjG,UAC5DwK,EAAiBF,EAAcG,QAC/BC,EAAY9J,cAEbiI,OAAO,CAACjI,MAAOyC,GAAQ,IAAI,SAAA4C,GAAC,OAAIV,GAAaU,EAAEjG,SAAQY,MAAOyC,GAAQ,IAAI,SAAA4C,GAAC,OAAIV,GAAaU,EAAEjG,WAE7F2K,EAAkB,IAAIC,cAAehK,SAAU,YAuBrD,OAtBA+J,EACKE,MAAM,MACNvB,OAAO,KACPJ,OAAM,SAAU4B,GAAK,OAAO,IAAIF,YAAaE,GAAGC,MAAMnK,iBAAkBoK,kBAAiB,MACzFxB,EAAEkB,GACFO,QAAQ,CAAEC,IAAK,GAAIC,MAAO,GAAIC,OAAQ,GAAIC,KAAM,KAChDC,SAAQ,GACRC,WAAW,wBACXC,WAAW,cACXC,YAAY,IACZC,UAAS,GACTnB,UAAUD,GACVG,MAAMD,GAGNmB,gBAAe,SAAU1F,GAAK,OAAOA,EAAElB,IAAI,MAC3C6G,aAAY,SAAU3F,GAAK,OAAOA,EAAElB,IAAI,MACxC8G,eAAc,SAAU5F,GAAK,OAAQA,EAAE1D,SACvCrE,OAAO0M,WAAYpB,EAAE,IAAIE,EAAE,KAAKoC,WAAW,IAAIC,eAAc,GAAMC,WAAW,IAC9E/G,QAAO,SAAAgH,GAAC,OAAI5G,GAAY4G,MACxBC,eAAc,SAAAjG,GAAC,OAAIA,EAAElB,IAAI,MAEvB4F,EAuJX,SAASwB,KACLxH,EACKqB,SAAQ,SAAUhH,GACfA,EAAMgB,KAAO,IAAIkG,KAAKlH,EAAMgB,MAC5BoM,EAAwBpN,EAAOwD,KAAG,MAuB9C,OA7ZA6J,qBAAU,WAENC,IAAsBnJ,KAAK4C,IACtBwG,OAAM,SAAA/J,GACH8J,IAA+BnJ,KAAK4C,SAE7C,IAGHsG,qBAAU,WACFhJ,IAkCJ+I,EAAwB,OAqB5B,WACI,GAAI/I,EAAM,CACN,IAAMmJ,EAAanJ,GAAQ,GACrBwC,EAAQ4G,IAAYD,GAC1B1G,GAASD,GAwGjB,SAAsBA,GAClB,IAAM6G,EAAe7G,EAAM0E,WAAU,SAAAtE,GAAC,OAAIA,EAAElB,OACtC4H,EAAgBD,EAAajC,QAE7BmC,EAAWhM,iBAAkBiI,OAAO9B,OAAO8F,KAAKxH,KAEhD6D,EAAQ0B,WAAYhK,SAAU,SACpCsI,EACK2B,MAAM,KACNvB,OAAO,KACPiB,UAAUmC,GACVI,OAAOlC,QAASmC,SAChB9B,QAAQ,CAAEC,IAAK,GAAIC,MAAO,GAAIC,OAAQ,GAAIC,KAAM,KAChD7B,EAAEoD,GACF3H,QAAO,SAAAgH,GAAC,OAAI5G,GAAY4G,MACxBC,eAAc,SAAAjG,GAAC,OAAIA,EAAElB,OAErBiI,IAAI,IACJC,2BAA0B,GAC1BxC,MAAMkC,EAAe,gCAE1BzD,EAAMgE,GAAG,oBAAoB,SAAC1K,EAAGwC,GACzBf,EAAaxB,SAASuC,GACtBd,EAAgBD,EAAaW,QAAO,SAAAqH,GAAC,OAAIA,IAAMjH,MAC9Cd,EAAgB,GAAD,mBAAKD,GAAL,CAAmBe,QAG3CR,EAAY0E,GA5HRiE,CAAatH,GACbwE,GAAgBxE,GAmNpBV,GAAQ6D,QAAU,CAAExH,MAAO,IAAI4D,KAE/B/B,EAAK2C,SAAQ,SAAAhH,GACLA,EAAMqH,QAASlB,GAAQ6D,QAAQvH,UAAY0D,GAAQ6D,QAAQvH,UAAY,GAAK,EACvEzC,EAAMsH,MAAOnB,GAAQ6D,QAAQnH,SAAWsD,GAAQ6D,QAAQnH,SAAW,GAAK,EAC5EsD,GAAQ6D,QAAQoE,UAAYjI,GAAQ6D,QAAQoE,UAAY,GAAK,EAElEjI,GAAQ6D,QAAQxH,MAAM6L,IAAIrO,EAAMa,UAC5Bb,EAAMI,WAAU+F,GAAQ6D,QAAQlH,YAAcqD,GAAQ6D,QAAQlH,YAAc,GAAK,GACrFqD,GAAQ6D,QAAQsE,eAAiBnI,GAAQ6D,QAAQsE,eAAiB,GAAKtO,EAAMsO,cAC7EnI,GAAQ6D,QAAQpH,UAAYuD,GAAQ6D,QAAQpH,UAAY,GAAK5C,EAAM4C,SACnEuD,GAAQ6D,QAAQrH,OAASwD,GAAQ6D,QAAQrH,OAAS,GAAK,KAW3DuD,EAAc,CACV1D,MAAO2D,GAAQ6D,QAAQxH,MAAM2G,KAC7B1G,SAAW0D,GAAQ6D,QAAQvH,UAAY,EACvCC,cAAeyD,GAAQ6D,QAAQsE,cAC/B3L,MAAOwD,GAAQ6D,QAAQrH,MACvBC,SAAUuD,GAAQ6D,QAAQpH,SAC1BE,WAAYqD,GAAQ6D,QAAQlH,WAC5BD,QAASsD,GAAQ6D,QAAQnH,QACzBE,UAAWoD,GAAQ6D,QAAQoE,WA/O3BjB,KACAxF,KA4KR,SAAsBd,GAClB,IAAM0H,EAAiB1H,EAAM0E,WAAU,SAAAtE,GAAC,OAAIA,EAAEjB,QACxCwI,EAAkBD,EAAe9C,QAEjCgD,EAAa7M,iBACdiI,OAAO,CAAC,WAAY,UAAW,aAC/BjB,MAAM,CAAC,UAAW,UAAW,YAE9BsB,EAAQ0B,WAAYhK,SAAU,cAClCsI,EAAM2B,MAAM,KACPvB,OAAO,KACPoE,YAAY,GACZnD,UAAUgD,GACV9C,MAAM+C,GACNvI,OAAOwI,GACPvB,eAAc,SAAAjG,GAAC,OAAIA,EAAElB,OACrB7G,OAAO0M,YAEZ1B,EAAMgE,GAAG,oBAAoB,SAAC1K,EAAGwC,GACzBb,EAAc1B,SAASuC,GACvBZ,EAAiBD,EAAcS,QAAO,SAAAqH,GAAC,OAAIA,IAAMjH,MAChDZ,EAAiB,GAAD,mBAAKD,GAAL,CAAoBa,QAG7CN,EAAYwE,GAnMRyE,CAAa9H,GAEb+E,eAtCJgD,MAlCD,CAACvK,IAEJgJ,qBAAU,WACFxG,IACAwE,GAAgBxE,IAAOuE,WAE5B,CAAC7E,GAAcM,KAElBwG,qBAAU,WACND,IACK5E,kBAAQnE,KAELkB,GACAA,EAAS2I,GAAG,oBAAoB,SAAC1K,EAAGwC,GAC5Bf,EAAaxB,SAASuC,GACtBd,EAAgBD,EAAaW,QAAO,SAAAqH,GAAC,OAAIA,IAAMjH,MAC9Cd,EAAgB,GAAD,mBAAKD,GAAL,CAAmBe,QAE3CP,GACAA,EAASyI,GAAG,oBAAoB,SAAC1K,EAAGwC,GAC5Bb,EAAc1B,SAASuC,GACvBZ,EAAiBD,EAAcS,QAAO,SAAAqH,GAAC,OAAIA,IAAMjH,MAChDZ,EAAiB,GAAD,mBAAKD,GAAL,CAAoBa,QAGjD2B,KACAwF,QAGL,CAAClI,EAAcE,IA8SlB0J,YAAc,QAAS,QAAS,CAC5BD,KAD4B,SACvBE,EAAK1E,GACN,IAAM2E,EAhBd,SAAsBD,GAClB,OAAO,uCACAA,EAAIE,cACJF,EAAIG,OAFX,IAGIvF,SAAUoF,EAAIzK,KAAK8E,KACnBrI,KAAMgO,EAAIzK,KAAKvD,KACfoO,UAAW,SACXC,WAAYL,EAAIzK,KAAK6E,KACrBkG,KAAMN,EAAIrO,OAASqO,EAAIE,aAAaK,OACpCC,aAAc,eAOAC,CAAaT,GACrBU,EAAYpF,EAAUqF,SAAS,OAAQ,CACzCV,MAAM,2BACCA,GADF,IAEDvE,EAAGsE,EAAItE,EACPE,EAAGoE,EAAIpE,MAOf,OAJIoE,EAAIzK,KAAKkF,QACTmG,IAAKnG,OAAOiG,EAAWV,EAAIzK,KAAKkF,OAASE,KAAKkG,GAAK,KAGhDH,KA0DX,yBAAKjP,UAAU,kBACX,kBAAC,IAAD,CAAY0C,MAAM,kBAAkB2M,SAAS,kDAG7C,kBAAC,IAAD,CAAM3M,MAAM,cAAW4M,UAAU,GAC7B,kBAAC,EAAD,CAAkBzN,WAAYA,EAAYC,YAAY,KAG1D,6BACA,kBAAC,IAAD,KACI,kBAAC,IAAD,CAAMY,MAAM,oBAAoB4M,UAAU,EAAOC,MAAOrJ,IACpD,yBAAKlG,UAAU,2BACX,yBAAKc,GAAG,cAIpB,6BACA,kBAAC,IAAD,CAAK2B,OAAQ,CAAC,GAAI,KACd,kBAAC,IAAD,CAAKM,KAAM,IACP,kBAAC,IAAD,CAAML,MAAM,oBAAc4M,UAAU,GAChC,yBAAKtP,UAAU,iBACX,yBAAKc,GAAG,WAMpB,kBAAC,IAAD,CAAKiC,KAAM,IACP,kBAAC,IAAD,CAAML,MAAM,iBAAiB4M,UAAU,GACnC,yBAAKtP,UAAU,yBACX,yBAAKc,GAAG,YAKxB,6BAEA,kBAAC,IAAD,CAAK2B,OAAQ,CAAC,GAAI,KACd,kBAAC,IAAD,CAAKM,KAAM,IACP,kBAAC,IAAD,CAAML,MAAM,oBAAoB4M,UAAU,GACtC,yBAAKtP,UAAU,6BACX,yBAAKc,GAAG,gBAIpB,kBAAC,IAAD,CAAKiC,KAAM,IACP,kBAAC,IAAD,CAAML,MAAM,2BAA2B4M,UAAU,GAC7C,yBAAKtP,UAAU,wBACX,yBAAKc,GAAG,mBAQxB,6BAEA,kBAAC,IAAD,OC5hBG0O,MATf,WACE,OACE,yBAAKxP,UAAU,OACb,kBAAC,EAAD,QCIcyP,QACW,cAA7BnR,OAAOC,SAASmR,UAEe,UAA7BpR,OAAOC,SAASmR,UAEhBpR,OAAOC,SAASmR,SAASC,MACvB,2DCZNC,IAAS/E,OAAO,kBAAC,EAAD,MAASgF,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMrM,MAAK,SAAAsM,GACjCA,EAAaC,kB","file":"static/js/main.ed40165a.chunk.js","sourcesContent":["const host = window.location.host\n\n// const websocketURL = \"ws://\" + host;\nconst websocketURL = \"ws://localhost:9000\";\n\nconst apiURL = \"http://localhost:9000\";\n\nexport { apiURL, websocketURL }","import { Comment } from 'antd';\nimport L from 'leaflet';\nimport ReactDOMServer from 'react-dom/server'\nimport React from 'react';\nimport * as d3 from 'd3';\n\nvar map = null;\nvar dataWithoutPosition = 0;\nvar legend = undefined;\nvar markersLayer = undefined\n\nexport function createMap(containerId) {\n    map = L.map(containerId, {\n        center: [0, 0],\n        zoom: 1,\n        layers: [\n            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {\n                attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n            }),\n        ]\n    })\n\n}\n\nexport function getMap() {\n    return map;\n}\n\nexport function getMarkersLayer() {\n    return markersLayer;\n}\n\nfunction createPopup(tweet) {\n\n    const content = <Comment\n        author={tweet.userName}\n        content={\n            <p>\n                {tweet.text}\n            </p>\n        }\n        datetime={tweet.date.toLocaleTimeString()}\n    ></Comment>\n    return ReactDOMServer.renderToString(\n        content\n    );\n}\n\nexport function clearMarkers() {\n    if (markersLayer) markersLayer.clearLayers()\n    dataWithoutPosition = 0;\n}\n\nexport function createMarker(tweet) {\n\n    if (!markersLayer) {\n        markersLayer = L.layerGroup().addTo(map)\n    }\n\n    const marker = L.marker(tweet.position, {\n        icon: L.divIcon({\n            className: 'css-icon',\n            html: `<div class=\"tweet-map-marker\"\n            style=\"background-color:${tweet.color}\"></div>`\n        })\n    })\n        .bindPopup(createPopup(tweet))\n\n    marker.id = tweet.id\n\n    return marker\n\n}\n\nexport function addMarker(tweet, duration = 20000, staticMap = false) {\n\n    if (!markersLayer) {\n        markersLayer = L.layerGroup().addTo(map)\n    }\n\n    if (tweet.position) {\n        const marker = createMarker(tweet)\n            .addTo(markersLayer)\n\n\n        if (!staticMap) {\n            setTimeout(() => {\n                marker.remove()\n            }, duration)\n        }\n    }\n    else {\n        dataWithoutPosition += 1\n        updateLegend()\n    }\n}\n\nfunction updateLegend() {\n    const text = (dataWithoutPosition > 1) ? `${dataWithoutPosition} tweets sem localização` : `${dataWithoutPosition} tweet sem localização`;\n    if (legend) {\n        if (dataWithoutPosition === 0) legend.remove()\n        else d3.select(\".map-legend\")\n            .text(text)\n    }\n    else {\n        legend = L.control({ position: 'bottomright' });\n        legend.onAdd = map => {\n            const div = L.DomUtil.create(\"div\", \"map-legend\")\n            div.innerHTML += text\n\n            return div\n        }\n\n        legend.addTo(map)\n    }\n}","import React from 'react';\nimport { Statistic, Row, Col, Tooltip, Divider } from 'antd';\nimport './TweetsStatistics.scss';\n\nconst columnSpan = 3\n\nexport default function TweetsStatistics({ statistics,\n  selectable = false,\n  onClick = () => false,\n  selected = []\n}) {\n\n  const { users = 0,\n    retweets = 0,\n    mediaAndLinks = 0,\n    total = 0,\n    mentions = 0,\n    replies = 0,\n    geolocated = 0,\n    originals = 0\n  } = statistics\n\n  return <div className=\"tweets-statistics-container\">\n    <Row gutter={[8, 16]}>\n\n      <Tooltip title=\"Total de tweets\" trigger=\"hover\" onVisibleChange={console.log}>\n        <Col span={columnSpan}>\n          <Statistic title=\"Total\" value={total} />\n        </Col>\n      </Tooltip>\n\n      <Tooltip title=\"Total de tweets com localização\">\n        <Col span={columnSpan}>\n          <Statistic title=\"Geolocalizados\" value={geolocated} />\n        </Col>\n      </Tooltip>\n\n      <Tooltip title=\"Número de usuários distintos twittando\">\n        <Col span={columnSpan}>\n          <Statistic title=\"Usuários\" value={users} />\n        </Col>\n      </Tooltip>\n\n      <Tooltip title=\"Quantidade de mídia e links compartilhadas\">\n        <Col span={columnSpan}>\n          <Statistic title=\"Mídia e Links\" value={mediaAndLinks} />\n        </Col>\n      </Tooltip >\n\n      <Tooltip title=\"Quantidade de menções realizadas\">\n        <Col span={columnSpan}>\n          <Statistic title=\"Menções\" value={mentions} />\n        </Col>\n      </Tooltip >\n\n      <Tooltip title=\"Total de retweets\">\n        <Col span={columnSpan} >\n          <div onClick={_ => onClick(\"retweet\")}>\n            <Statistic className={`retweets ${selectable ? \"selectable\" : \"\"} ${selected.includes(\"retweet\") ? \"selected\" : \"\"}`} title=\"Retweets\" value={retweets} />\n          </div>\n        </Col>\n      </Tooltip >\n\n      <Tooltip title=\"Total de respostas\">\n        <Col span={columnSpan}>\n          <div onClick={_ => onClick(\"reply\")}>\n            <Statistic className={`${selectable ? \"selectable\" : \"\"} ${selected.includes(\"reply\") ? \"selected\" : \"\"}`} title=\"Respostas\" value={replies} />\n          </div>\n        </Col>\n      </Tooltip >\n\n      <Tooltip title=\"Total de tweets que não são retweets ou respostas\">\n        <Col span={columnSpan}>\n          <div onClick={_ => onClick(\"original\")}>\n            <Statistic className={`${selectable ? \"selectable\" : \"\"} ${selected.includes(\"original\") ? \"selected\" : \"\"}`} title=\"Originais\" value={originals} />\n          </div>\n        </Col>\n      </Tooltip >\n\n\n    </Row >\n\n\n  </div >\n\n}","import React from 'react';\nimport './RealTimeContainer.scss'\nimport { useRef } from 'react';\nimport crossfilter from 'crossfilter';\nimport { useState } from 'react';\nimport { useEffect } from 'react';\nimport { Input, Spin, Tag, PageHeader, Row, Col, Card } from 'antd';\nimport { Chart } from '@antv/g2';\nimport { isEmpty, sum } from 'rambda';\nimport * as SocketController from '../../services/SocketController';\nimport * as MapController from '../../map/MapController';\nimport CountDown from 'ant-design-pro/lib/CountDown';\nimport TweetsStatistics from './TweetsStatistics';\nimport TrendsContainer from './TrendsContainer';\n\nconst { Search } = Input;\n\nconst graphRefreshTimeout = 1500\nconst timeWindowSize = 0.5 * 60 * 1000\n\nexport default function RealTimeContainer() {\n\n    const [statistics, setStatistics] = useState({});\n    const [targetTime, setTargetTime] = useState();\n\n    const [seriesChart, setSeriesChart] = useState();\n\n    const metrics = useRef({ users: new Set() })\n\n    const [barChart, setBarChart] = useState();\n\n    const [search, setSearch] = useState(\"\");\n\n    const colors = [\n        \"#1F77B4\",\n        \"#278944\"\n        // \"#FF7F0E\",\n        // \"#2CA02C\",\n        // \"#9467BD\",\n        // \"#E377C2\",\n    ];\n\n    const [takenColors, setTakenColors] = useState([]);\n    const keyColor = useRef([]);\n\n    const data = useRef([])\n    const count = useRef({})\n\n    function addSocket(keyword = \"\") {\n        setSearch(\"\")\n        console.log(\"socket:\", keyword)\n        const color = colors.filter(c => !takenColors.map(c => c[1]).includes(c))[0]\n        count.current[keyword] = { value: 0, color };\n        setTakenColors([...takenColors, [keyword, color]])\n        SocketController.addSocket({ keyword, color })\n        setTargetTime(new Date().getTime() + graphRefreshTimeout)\n    }\n\n    function updateAll() {\n        drawSeriesChart()\n        drawBarChart()\n        setStatistics({\n            users: metrics.current.users.size,\n            retweets: (metrics.current.retweets || 0),\n            mediaAndLinks: metrics.current.mediasAndLink,\n            total: metrics.current.total,\n            mentions: metrics.current.mentions,\n            geolocated: metrics.current.geolocated,\n            replies: metrics.current.replies,\n            originals: metrics.current.original\n        })\n\n        setTargetTime(new Date().getTime() + graphRefreshTimeout)\n    }\n\n    useEffect(() => {\n        // series chart listener to collect all tweets\n\n        SocketController.addListenner(\"time\", ({ color, key, date }) => {\n            count.current[key].value += 1;\n            data.current.push({ color, key, date });\n        });\n\n        SocketController.addListenner(\"map\", tweet => {\n            MapController.addMarker(tweet);\n        });\n\n        SocketController.addListenner(\"metrics\", ({ userName, retweet, reply, mediasAndLink, mentions, position }) => {\n            metrics.current.users.add(userName)\n            if (retweet) metrics.current.retweets = (metrics.current.retweets || 0) + 1\n            else if (reply) metrics.current.replies = (metrics.current.replies || 0) + 1\n            else metrics.current.original = (metrics.current.original || 0) + 1\n            if (position) metrics.current.geolocated = (metrics.current.geolocated || 0) + 1\n            metrics.current.mediasAndLink = (metrics.current.mediasAndLink || 0) + mediasAndLink\n            metrics.current.total = (metrics.current.total || 0) + 1\n            metrics.current.mentions = (metrics.current.mentions || 0) + mentions\n\n        })\n\n        MapController.createMap(\"map\");\n        drawSeriesChart();\n        drawBarChart();\n    }, [])\n\n    useEffect(() => {\n        Object.keys(metrics.current).forEach(k => metrics.current[k] = 0)\n        metrics.current.users = new Set();\n        data.current.splice(0, data.current.length)\n        Object.keys(count.current).forEach(k => count.current[k].key = 0)\n        MapController.clearMarkers();\n        keyColor.current = takenColors\n    }, [takenColors])\n\n    function getSeriesData() {\n        if (isEmpty(data.current)) {\n            return []\n        }\n\n        const now = data.current[data.current.length - 1].date.getTime() - 1000\n        const cleanData = data.current.filter(d => d.date.getTime() < now &&\n            now - d.date.getTime() < timeWindowSize)\n        const facts = crossfilter(cleanData)\n        const dimension = facts.dimension(d => [d.key, d.date, d.color])\n        const group = dimension.group().reduceSum(_ => 1)\n\n        const seriesData = group.all()\n            .sort((a, b) => a.key[1] < b.key[1])\n            .map(d => ({ keyword: d.key[0], date: d.key[1].toLocaleTimeString(), color: d.key[2], value: d.value }))\n\n        // console.log(seriesData)\n\n        return seriesData\n    }\n\n    function handleRemove(tag) {\n        SocketController.removeSocket(tag)\n        delete count.current[tag]\n        // if (takenColors.length === 1) seriesChart.destroy();\n        setTakenColors(takenColors.filter(c => c[0] !== tag))\n    }\n\n    function drawSeriesChart() {\n        const chartData = getSeriesData()\n        if (isEmpty(chartData))\n            return;\n\n        if (seriesChart) {\n            seriesChart.changeData(chartData)\n            return;\n        }\n\n        const chart = new Chart({\n            container: 'series',\n            autoFit: true,\n            height: 200,\n            renderer: 'svg'\n        })\n\n        chart.data(chartData)\n\n        chart\n            .line()\n            .position('date*value')\n            .color('keyword', k => {\n                return keyColor.current.filter(c => c[0] === k)[0][1]\n            })\n            .label(false)\n\n        chart.tooltip({\n            showCrosshairs: true,\n            shared: true,\n        });\n\n        chart.axis('date', {\n            animateOption: {\n                update: {\n                    duration: 1000,\n                    easing: 'easeLinear'\n                }\n            }\n        });\n\n        chart.render()\n        setSeriesChart(chart)\n    }\n\n    function getBarData() {\n        return Object.entries(count.current)\n            .map(([key, value]) => ({ ...value, key }))\n            .sort((a, b) => a.value < b.value)\n    }\n\n    function drawBarChart() {\n\n        const data = getBarData()\n\n        if (isEmpty(data))\n            return;\n\n        if (barChart) {\n            barChart.annotation().clear(true);\n            // barChart.annotation().text({\n            //     position: ['95%', '10%'],\n            //     content: sum(data.map(d => d.value)) + \" tweets\",\n            //     style: {\n            //         fontSize: 40,\n            //         fontWeight: 'bold',\n            //         fill: '#dadada',\n            //         textAlign: 'end'\n            //     },\n            //     animate: false,\n            // });\n\n            barChart.changeData(data)\n            return;\n        }\n\n        const chart = new Chart({\n            container: 'bar',\n            autoFit: true,\n            height: 300,\n            renderer: 'svg'\n            // padding: [20, 60]\n        });\n        // @ts-ignore\n        chart.data(data);\n        chart.coordinate('rect').transpose();\n        chart.legend(false);\n        chart.tooltip(true);\n        // chart.axis('value', false);\n        // chart.axis('key', {\n        //     animateOption: {\n        //         update: {\n        //             duration: 1000,\n        //             easing: 'easeLinear'\n        //         }\n        //     }\n        // });\n\n        // chart.annotation().text({\n        //     position: ['95%', '10%'],\n        //     content: sum(data.map(d => d.value)) + \" tweets\",\n        //     style: {\n        //         fontSize: 40,\n        //         fontWeight: 'bold',\n        //         fill: '#dadada',\n        //         textAlign: 'end'\n        //     },\n        //     animate: false,\n        // });\n\n        chart\n            .interval()\n            .position('key*value')\n            .color('key', k => {\n                return keyColor.current.filter(c => c[0] === k)[0][1]\n            })\n            .animate({\n                appear: {\n                    duration: 1000,\n                    easing: 'easeLinear'\n                },\n                update: {\n                    duration: 500,\n                    easing: 'easeLinear'\n                }\n            });\n\n        chart.render();\n        setBarChart(chart)\n    }\n\n    return <div className=\"main-container\">\n        <PageHeader title=\"Tweets monitor\" subTitle=\"Monitore assuntos em tempo real (ou quase isso)\">\n\n            <div className=\"trends-container\">\n                <TrendsContainer onClick={addSocket} disabled={takenColors.length == 2} />\n            </div>\n\n            <div className=\"tweets-search-container\">\n                <Search\n                    enterButton\n                    disabled={takenColors.length == 2}\n                    placeholder=\"Ou entre seu\"\n                    onSearch={addSocket}\n                    value={search}\n                    onChange={e => setSearch(e.target.value)}\n                    className=\"tweets-search\" />\n                <div className=\"tags-container\">\n                    {takenColors.map(([tag, color]) =>\n                        <Tag\n                            key={tag}\n                            closable={true}\n                            color={color}\n                            onClose={_ => handleRemove(tag)}\n                        >\n                            <p>{tag}</p>\n                        </Tag>\n                    )\n                    }\n                </div>\n            </div>\n        </PageHeader>\n\n        <Card title=\"Métricas\" bordered={false}>\n            <TweetsStatistics statistics={statistics} />\n        </Card>\n\n        <Card title=\"Contagem temporal\" bordered={false}>\n            <div className=\"series-container\">\n                <div id=\"series\"></div>\n            </div>\n        </Card>\n\n\n        <Row gutter={[16, 16]}>\n            <Col span={12}>\n                <Card title=\"Localização\" bordered={false}>\n                    <div className=\"map-container\">\n                        <div id=\"map\"></div>\n                    </div >\n                </Card>\n            </Col>\n\n            <Col span={12}>\n                <Card title=\"Contagem total\" bordered={false}>\n                    <div className=\"bars-container\">\n                        <div id=\"bar\"></div>\n                    </div>\n                </Card>\n\n            </Col>\n        </Row>\n\n        <CountDown\n            className=\"count-down-refresh\"\n            target={targetTime}\n            onEnd={updateAll}\n        />\n\n    </div >\n        ;\n\n}","import React from 'react'\nimport { Tabs } from 'antd';\nimport 'antd/dist/antd.css';\nimport \"./MapContainer.scss\";\nimport RealTimeContainer from './RealTimeContainer/RealTimeContainer';\n\nconst { TabPane } = Tabs;\n\nexport default function MainContainer() {\n    return <RealTimeContainer />;\n}","import axios from 'axios';\nimport { apiURL } from '.';\n\nlet API_URL = apiURL;\n\nconst service = axios.create({ baseURL: API_URL });\nexport default {\n\n    find() {\n        return service.get(\"/historical-tweets\").then(res => res.data)\n    },\n\n    getStaticData() {\n        return axios.get(\"/data.json\").then(res => res.data)\n    }\n\n}\n","import React from 'react';\nimport { Input, PageHeader, Row, Col, Card, Checkbox, Select } from 'antd';\nimport { useRef } from 'react';\nimport crossfilter from 'crossfilter';\nimport { useState } from 'react';\nimport { useEffect } from 'react';\nimport { Chart, registerShape, Util } from '@antv/g2';\nimport { isEmpty } from 'lodash';\nimport DataSet from '@antv/data-set';\nimport * as d3 from \"d3\";\nimport * as dc from \"dc\";\nimport _ from 'lodash';\nimport { quantileSeq } from \"mathjs\"\n\nimport * as MapController from '../../map/MapController';\nimport './StaticMainContainer.scss';\n\n// import data from './data.json';\nimport TweetsStatistics from '../RealTimeContainer/TweetsStatistics';\nimport TwitterService from '../../services/TwitterService';\n\nconst { Option } = Select\n\nconst maxWords = 50;\nconst wordsColors = [\"#646464\", \"#818181\", \"#a2a2a2\", \"#ffffff\"]\n\nconst formatFunctions = {\n    minutes: d3.timeMinute,\n    seconds: d3.timeSecond,\n    hour: d3.timeHour,\n    day: d3.timeDay\n}\n\nexport function StaticMainContainer() {\n\n    const [data, setData] = useState();\n\n    const [selectedKeys, setSelectedKeys] = useState([])\n    const keyFilter = t => selectedKeys.length === 0 || selectedKeys.includes(t.key)\n\n    const [selectedTypes, setSelectedTypes] = useState([])\n    const typeFilter = t => selectedTypes.length === 0 || selectedTypes.includes(t.type)\n\n    const wordChart = useRef()\n\n    const [barChart, setBarChart] = useState()\n    const [pieChart, setPieChart] = useState()\n\n    const filteredData = (data || [])\n        .filter(keyFilter)\n        .filter(typeFilter)\n\n    const colors = [\"#3366cc\", \"#dc3912\", \"#ff9900\", \"#109618\", \"#990099\", \"#0099c6\", \"#dd4477\", \"#66aa00\", \"#b82e2e\", \"#316395\", \"#994499\", \"#22aa99\", \"#aaaa11\", \"#6633cc\", \"#e67300\", \"#8b0707\", \"#651067\", \"#329262\", \"#5574a6\", \"#3b3eac\"]\n\n    const [statistics, setStatistics] = useState({});\n    const metrics = useRef({ users: new Set() })\n    const [coloredKeys, setColors] = useState([]);\n\n    const [dateFormater, setDateFormater] = useState(() => formatFunctions.seconds)\n    const dateFormatSelect = <Select defaultValue={\"seconds\"} onChange={f => setDateFormater(() => formatFunctions[f])}>\n        <Option key={0} value=\"seconds\">Segundos</Option>\n        <Option key={1} value=\"minutes\">Minutos</Option>\n        <Option key={1} value=\"hour\">Hora</Option>\n        <Option key={1} value=\"day\">Dia</Option>\n    </Select>\n\n    const [facts, setFacts] = useState()\n\n    function getTweetType(tweet) {\n        if (tweet.retweet) return \"Retweet\"\n        else if (tweet.reply) return \"Resposta\"\n        else return \"Original\"\n    }\n\n    function processData(data) {\n        data.forEach(d => {\n            d.date = new Date(parseInt(d.date.$numberLong))\n            d.type = getTweetType(d)\n        });\n        setData(addColorToData(data))\n    }\n\n    useEffect(() => {\n        /** Backend's Request to get historical tweets*/\n        TwitterService.find().then(processData)\n            .catch(_ => {\n                TwitterService.getStaticData().then(processData)\n            })\n    }, [])\n\n\n    useEffect(() => {\n        if (data) init();\n    }, [data])\n\n    useEffect(() => {\n        if (facts) {\n            drawSeriesChart(facts).render()\n        }\n    }, [dateFormater, facts])\n\n    useEffect(() => {\n        MapController.clearMarkers()\n        if (!isEmpty(data)) {\n\n            if (barChart)\n                barChart.on('filtered.monitor', (_, type) => {\n                    if (selectedKeys.includes(type))\n                        setSelectedKeys(selectedKeys.filter(k => k !== type))\n                    else setSelectedKeys([...selectedKeys, type])\n                });\n            if (pieChart)\n                pieChart.on('filtered.monitor', (_, type) => {\n                    if (selectedTypes.includes(type))\n                        setSelectedTypes(selectedTypes.filter(k => k !== type))\n                    else setSelectedTypes([...selectedTypes, type])\n                });\n\n            drawWordChart();\n            addMarkers();\n        }\n        // draw()\n    }, [selectedKeys, selectedTypes])\n\n    //** Initializations */\n    function init() {\n        MapController.createMap(\"map\");\n        draw();\n    }\n\n    // function updateAreaFilter(e, idDimension) {\n    //     const visible = new Set()\n\n    //     data.forEach(d => {\n    //         if(!d.position) visible.add\n    //     })\n\n    //     MapController.getMarkersLayer().eachLayer(marker => {\n    //         if (e.target.getBounds().contains(marker.getLatLng()))\n    //             visible.add(marker.id)\n    //     })\n\n    //     console.log(visible)\n\n    //     idDimension.filterFunction(id => visible.has(id))\n    // }\n\n    function draw() {\n        if (data) {\n            const factsData = (data || [])\n            const facts = crossfilter(factsData)\n            setFacts(facts)\n            // const idDimension = facts.dimension(d => d.id)\n\n\n            // MapController.getMap()\n            //     .on('moveend', e => updateAreaFilter(e, idDimension))\n\n            drawBarChart(facts);\n            drawSeriesChart(facts);\n            configStats();\n            addMarkers();\n            drawWordChart();\n            drawSunburst(facts);\n\n            dc.renderAll()\n        }\n\n    }\n\n    /**\n     * \n     * ###########  Draw Charts  ###########\n     * \n    */\n\n    /** Word Cloud */\n    function drawWordChart() {\n\n        const dv = configWorldCloud();\n        if (!dv) return\n        const [min, max] = dv.range('value');\n\n        const colorRange = d3.scaleQuantize()\n\n            .domain(quantileSeq(dv.rows.map(d => d.value), [0, 0.33, 0.66, 1]))\n            .range(wordsColors)\n\n        if (wordChart.current) {\n            wordChart.current.destroy()\n        }\n\n        const chart = new Chart({\n            container: 'word-cloud',\n            autoFit: true,\n            height: 300,\n            padding: 0\n        });\n\n        chart.data(dv.rows);\n        chart.scale({\n            x: { nice: false },\n            y: { nice: false }\n        });\n        chart.legend(false);\n        chart.axis(false);\n        chart.tooltip({\n            showTitle: false,\n            showMarkers: false\n        });\n        chart.coordinate().reflect();\n        chart.point()\n            .position('x*y')\n            .color('value', v => {\n\n                return colorRange(v)\n            })\n            .shape('cloud');\n        chart.render();\n\n        wordChart.current = chart\n    }\n\n    function configWorldCloud() {\n        const wc = getWordCount()\n        if (isEmpty(wc))\n            return\n        const dv = new DataSet.View().source(wc);\n\n        const [min, max] = dv.range('value');\n        dv.transform({\n            spiral: 'rectangular',\n            type: 'tag-cloud',\n            fields: ['key', 'value'],\n            font: 'serif',\n            size: [600, 300],\n            padding: 0,\n            timeInterval: Infinity,\n            rotate() {\n                let random = ~~(Math.random() * 4) % 4;\n                if (random === 2) {\n                    random = 0;\n                }\n                return random * 90; // 0, 90, 270\n            },\n            fontSize(d) {\n                const [minFont, maxFont] = [24, 80]\n                const size = ((d.value - min) / (max - min)) * (maxFont - minFont) + minFont\n                return size;\n            }\n        });\n        return dv;\n    }\n\n    /** Bar Chart */\n    function drawBarChart(facts) {\n        const keyDimension = facts.dimension(d => d.key)\n        const keyCountGroup = keyDimension.group()\n\n        const keyScale = d3.scaleOrdinal().domain(Object.keys(coloredKeys))\n\n        const chart = dc.barChart(d3.select(\"#bar\"))\n        chart\n            .width(600)\n            .height(300)\n            .dimension(keyDimension)\n            .xUnits(dc.units.ordinal)\n            .margins({ top: 10, right: 20, bottom: 50, left: 50 })\n            .x(keyScale)\n            .colors(k => coloredKeys[k])\n            .colorAccessor(d => d.key)\n            // .centerBar(true)\n            .gap(50)\n            .renderHorizontalGridLines(true)\n            .group(keyCountGroup, 'Contagem dos tipos de crimes')\n\n        chart.on('filtered.monitor', (_, type) => {\n            if (selectedKeys.includes(type))\n                setSelectedKeys(selectedKeys.filter(k => k !== type))\n            else setSelectedKeys([...selectedKeys, type])\n        });\n\n        setBarChart(chart)\n\n    }\n\n    /** Series Chart */\n    function drawSeriesChart(facts) {\n        const timeDimension = facts.dimension(d => [d.key, dateFormater(d.date)])\n        const timeCountGroup = timeDimension.group()\n        const timeScale = d3\n            .scaleTime()\n            .domain([d3.min(data || [], d => dateFormater(d.date)), d3.max(data || [], d => dateFormater(d.date))])\n\n        const dateSeriesChart = new dc.SeriesChart(d3.select(\"#series\"));\n        dateSeriesChart\n            .width(1200)\n            .height(300)\n            .chart(function (c) { return new dc.LineChart(c).curve(d3.curveCardinal).renderDataPoints(true); })\n            .x(timeScale)\n            .margins({ top: 10, right: 10, bottom: 50, left: 80 })\n            .brushOn(false)\n            .yAxisLabel(\"Quantidade de Tweets\")\n            .xAxisLabel(\"Horário\")\n            .clipPadding(10)\n            .elasticY(true)\n            .dimension(timeDimension)\n            .group(timeCountGroup)\n            // .mouseZoomable(true)\n            // .brushOn(true)\n            .seriesAccessor(function (d) { return d.key[0]; })\n            .keyAccessor(function (d) { return d.key[1]; })\n            .valueAccessor(function (d) { return +d.value; })\n            .legend(dc.legend().x(80).y(284).itemHeight(13).autoItemWidth(true).horizontal(1))\n            .colors(k => coloredKeys[k])\n            .colorAccessor(d => d.key[0]);\n\n        return dateSeriesChart\n\n        // dateSeriesChart.on('filtered.monitor', e => {\n        //     console.log(dateFilter, e._filters[0])\n        //     if (e._filters[0]) {\n        //         const [from, to] = e._filters[0].map(t => t.getTime())\n\n        //         setDateFilter(() => t => t.date.getTime() >= from && t.date.getTime() <= to)\n        //     } else {\n        //         setDateFilter(() => t => true)\n        //     }\n\n        // });\n\n        // dateSeriesChart.xAxis().ticks(4)\n    }\n\n    function drawSunburst(facts) {\n        const typesDimension = facts.dimension(d => d.type)\n        const typesCountGroup = typesDimension.group()\n\n        const colorScale = d3.scaleOrdinal()\n            .domain([\"Resposta\", \"Retweet\", \"Original\"])\n            .range([\"#46EDC8\", \"#374D7C\", \"#FDF289\"])\n\n        var chart = dc.pieChart(d3.select(\"#sunburst\"));\n        chart.width(600)\n            .height(295)\n            .innerRadius(0)\n            .dimension(typesDimension)\n            .group(typesCountGroup)\n            .colors(colorScale)\n            .colorAccessor(d => d.key)\n            .legend(dc.legend())\n\n        chart.on('filtered.monitor', (_, type) => {\n            if (selectedTypes.includes(type))\n                setSelectedTypes(selectedTypes.filter(k => k !== type))\n            else setSelectedTypes([...selectedTypes, type])\n        });\n\n        setPieChart(chart)\n    }\n\n\n    /**\n     * \n     * ###########  Processing Data  ###########\n     * \n    */\n\n    /** Satistics */\n    function configStats() {\n        metrics.current = { users: new Set() }\n\n        data.forEach(tweet => {\n            if (tweet.retweet) metrics.current.retweets = (metrics.current.retweets || 0) + 1\n            else if (tweet.reply) metrics.current.replies = (metrics.current.replies || 0) + 1\n            else metrics.current.original = (metrics.current.original || 0) + 1\n\n            metrics.current.users.add(tweet.userName);\n            if (tweet.position) metrics.current.geolocated = (metrics.current.geolocated || 0) + 1\n            metrics.current.mediasAndLink = (metrics.current.mediasAndLink || 0) + tweet.mediasAndLink\n            metrics.current.mentions = (metrics.current.mentions || 0) + tweet.mentions\n            metrics.current.total = (metrics.current.total || 0) + 1\n        })\n\n        // filteredData.forEach(function (tweet) {\n        //     metrics.current.users.add(tweet.userName);\n        //     if (tweet.position) metrics.current.geolocated = (metrics.current.geolocated || 0) + 1\n        //     metrics.current.mediasAndLink = (metrics.current.mediasAndLink || 0) + tweet.mediasAndLink\n        //     metrics.current.mentions = (metrics.current.mentions || 0) + tweet.mentions\n        //     metrics.current.total = (metrics.current.total || 0) + 1\n        // });\n\n        setStatistics({\n            users: metrics.current.users.size,\n            retweets: (metrics.current.retweets || 0),\n            mediaAndLinks: metrics.current.mediasAndLink,\n            total: metrics.current.total,\n            mentions: metrics.current.mentions,\n            geolocated: metrics.current.geolocated,\n            replies: metrics.current.replies,\n            originals: metrics.current.original\n        })\n    }\n\n    /**\n     * \n     * ###########  Auxiliary Functions  ###########\n     * \n    */\n\n    function getTextAttrs(cfg) {\n        return {\n            ...cfg.defaultStyle,\n            ...cfg.style,\n            fontSize: cfg.data.size,\n            text: cfg.data.text,\n            textAlign: 'center',\n            fontFamily: cfg.data.font,\n            fill: cfg.color || cfg.defaultStyle.stroke,\n            textBaseline: 'Alphabetic'\n        };\n    }\n\n    // 给point注册一个词云的shape\n    registerShape('point', 'cloud', {\n        draw(cfg, container) {\n            const attrs = getTextAttrs(cfg);\n            const textShape = container.addShape('text', {\n                attrs: {\n                    ...attrs,\n                    x: cfg.x,\n                    y: cfg.y\n                }\n            });\n            if (cfg.data.rotate) {\n                Util.rotate(textShape, cfg.data.rotate * Math.PI / 180);\n            }\n\n            return textShape;\n        }\n    });\n\n\n\n    function addColorToData(data) {\n        const keyColor = {\n            // retweet: \"white\",\n            // reply: \"magenta\",\n            // original: \"black\"\n        }\n        let i = 0\n\n        const newData = data.map(t => {\n            if (keyColor[t.key]) return { ...t, color: keyColor[t.key] }\n            else {\n                if (i > colors.length - 1) return t\n                keyColor[t.key] = colors[i]\n                i += 1\n                return { ...t, color: keyColor[t.key] }\n            }\n        }).filter(t => t.color)\n\n        setColors(keyColor);\n        return newData\n    }\n\n\n    /** Add markers to map */\n    function addMarkers() {\n        filteredData\n            .forEach(function (tweet) {\n                tweet.date = new Date(tweet.date);\n                MapController.addMarker(tweet, _, true);\n            });\n    }\n\n    function getWordCount() {\n        const wc = {}\n\n        filteredData.forEach(({ wordCount }) => {\n            Object.entries(wordCount).map(([word, count]) => wc[word] = count + (wc[word] || 0))\n        })\n\n        const wordCount = Object.entries(wc)\n            .map(([key, value]) => ({ key, value }))\n\n        wordCount.sort((a, b) => b.value - a.value)\n\n        if (wordCount.length <= maxWords) return wordCount\n        else return wordCount.slice(0, maxWords)\n    }\n\n\n    /** Render */\n\n    return (\n        <div className=\"main-container\">\n            <PageHeader title=\"Tweets Analyzer\" subTitle=\"Análise histórica dos tweets consumidos\">\n                {/* <CheckboxGroup options={Object.keys(coloredKeys)} value={selectedKeys} onChange={setSelectedKeys} /> */}\n            </PageHeader>\n            <Card title=\"Métricas\" bordered={false}>\n                <TweetsStatistics statistics={statistics} selectable={false} />\n            </Card>\n\n            <br />\n            <Row>\n                <Card title=\"Contagem temporal\" bordered={false} extra={dateFormatSelect}>\n                    <div className=\"static-series-container\">\n                        <div id=\"series\"></div>\n                    </div>\n                </Card>\n            </Row>\n            <br />\n            <Row gutter={[16, 16]}>\n                <Col span={12}>\n                    <Card title=\"Localização\" bordered={false}>\n                        <div className=\"map-container\">\n                            <div id=\"map\"></div>\n                        </div >\n                    </Card>\n\n\n                </Col>\n                <Col span={12}>\n                    <Card title=\"Contagem total\" bordered={false}>\n                        <div className=\"static-bars-container\">\n                            <div id=\"bar\"></div>\n                        </div>\n                    </Card>\n                </Col>\n            </Row>\n            <br />\n\n            <Row gutter={[16, 16]}>\n                <Col span={12}>\n                    <Card title=\"Contagem por tipo\" bordered={false}>\n                        <div className=\"static-sunburst-container\">\n                            <div id=\"sunburst\"></div>\n                        </div>\n                    </Card>\n                </Col>\n                <Col span={12}>\n                    <Card title=\"Palavras mais utilizadas\" bordered={false}>\n                        <div className=\"word-cloud-container\">\n                            <div id=\"word-cloud\"></div>\n                        </div>\n                    </Card>\n\n\n                </Col>\n\n            </Row>\n            <br />\n\n            <Row>\n\n            </Row>\n        </div>\n    );\n}","import React from 'react';\nimport './App.css';\nimport MainContainer from './components/MainContainer';\nimport { StaticMainContainer } from './components/Statics/StaticMainContainer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <StaticMainContainer />\n      {/* <MainContainer /> */}\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}